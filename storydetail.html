<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Your Story — Read with Sounds (Beta) | StoryBuds</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800&family=Inter:wght@400;600&family=Alegreya:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />
  <script src="script.js"></script>

  <style>
    /* === Local layout polish (kept) === */
    .detail-wrap { max-width: 980px; margin: 20px auto; padding: 0 16px; }
    .soundbar {
      position: sticky; top: 68px; z-index: 10;
      display: grid; grid-template-columns: 1fr auto auto auto; gap: 8px;
      align-items: center; background: rgba(255,255,255,0.9);
      border: 1px solid #eee9fb; border-radius: 14px; padding: 10px 12px;
      box-shadow: var(--shadow);
    }
    .soundbar .status { color: #3a3450; font-weight: 600; }
    .soundbar .hint   { color: var(--muted); font-size: 13px; }
    .sfx-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .sfx-row .btn { padding: 10px 14px; font-weight: 700; }
    .inline-field { display:flex; align-items:center; gap:8px; }
    .inline-field input[type="range"] { width: 160px; }
    .story-reader { margin-top: 16px; }
    .badge-beta { display:inline-block; margin-left:6px; font-size:12px; font-weight:800; padding:2px 8px; border-radius:999px; background:#fbf9ff; border:1px solid #eee9fb; color: var(--plum-dark); }

    /* === STT Debug Panel === */
    .stt-debug { margin-top:12px; border:1px solid #eee9fb; border-radius:14px; background:rgba(255,255,255,0.9); box-shadow:var(--shadow); padding:12px; }
    .stt-controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .stt-panels { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
    .stt-panel { display:flex; flex-direction:column; gap:6px; }
    .stt-title { font-weight:700; color:#3a3450; font-size:14px; }
    .stt-box { min-height:80px; padding:10px; border:1px solid #eee9fb; border-radius:10px; background:#fff; overflow:auto; }
    .monospace { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap; }
    .stt-meter-row { display:flex; align-items:center; gap:12px; margin-top:10px; }
    .stt-meter { flex:1; height:10px; background:#f2f2f6; border-radius:999px; overflow:hidden; border:1px solid #eee9fb; }
    .stt-meter span { display:block; height:100%; width:0%; background:#8E44EC; transition: width .08s linear; }

    /* Hide heavy UI by default — "production mode" */
    .dev-only { display: none !important; }

    /* Sticky single CTA for production */
    .sticky-listen {
      position: fixed;
      left: 16px;
      right: 16px;
      bottom: 18px;
      z-index: 20;
      border-radius: 999px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      font-weight: 800;
    }

    /* Short helper hint under title */
    .listen-hint {
      color: var(--muted);
      font-size: 13px;
      margin: 6px 0 0;
      text-align: center;
    }

    @media (max-width:900px){
      .soundbar{ grid-template-columns:1fr; }
      .stt-panels{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body class="fade-in">
  <!-- Topbar -->
  <header class="topbar">
    <a href="index.html" class="logo">
      <span class="logo-badge"><img src="logo.png" alt="StoryBuds logo" /></span>
    </a>
    <div class="top-actions">
      <button class="cart-btn" id="cartBtn" aria-label="Cart">
        <svg class="cart-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M3 3h2l3.6 9.59a1 1 0 0 0 .92.65H17a1 1 0 0 0 .96-.74L20 6H6"
                stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="9" cy="20" r="1" fill="currentColor"></circle>
          <circle cx="17" cy="20" r="1" fill="currentColor"></circle>
        </svg>
        <span class="cart-count" id="cartCount">0</span>
      </button>
      <button class="hamburger" id="menuBtn" aria-label="Menu">☰</button>
    </div>
    <nav id="menu" class="menu hidden" aria-label="Main navigation">
      <a href="home.html">Home</a>
      <a href="create.html">Create Stories</a>
      <a href="#">My Profile</a>
    </nav>
  </header>

  <main class="detail-wrap">
    <h1>Read with Sounds <span class="badge-beta">Beta</span></h1>
    <p class="listen-hint">Tap “Start listening” and read the story aloud — sound effects will follow you.</p>

    <!-- ✅ Production CTA: the only visible control by default -->
    <button class="btn sticky-listen" id="toggleMic">▶️ Start listening</button>

    <!-- Controls (kept in DOM for logic, but hidden by default) -->
    <section class="soundbar dev-only" id="soundbar">
      <div>
        <div class="status" id="micStatus">Microphone: idle</div>
        <div class="hint" id="micHint">Tap “Start listening” and read the story aloud.</div>
        <div class="sfx-row" id="manualSfx">
          <button class="btn ghost" data-sfx="whoosh">Whoosh</button>
          <button class="btn ghost" data-sfx="plip">Plip-plop</button>
          <button class="btn ghost" data-sfx="wind">Wind</button>
          <button class="btn ghost" data-sfx="chime">Magic chime</button>
          <button class="btn ghost" data-sfx="bark">Puppy bark (soft)</button>
          <button class="btn ghost" data-sfx="lullaby">Lullaby (phrase)</button>
          <button class="btn ghost" data-sfx="stop">Stop ambience</button>
        </div>
      </div>

      <!-- Volume -->
      <div class="inline-field">
        <label for="vol" class="muted">Volume</label>
        <input id="vol" type="range" min="0" max="1" step="0.01" value="0.35" />
      </div>

      <!-- Ambience -->
      <div class="inline-field">
        <label for="amb" class="muted">Ambience</label>
        <select id="amb">
          <option value="auto" selected>Auto</option>
          <option value="off">Off</option>
          <option value="forest">Forest</option>
          <option value="ocean">Ocean</option>
          <option value="rain">Rain</option>
          <option value="night">Night</option>
          <option value="castle">Castle</option>
          <option value="pad">Soft pad</option>
        </select>
      </div>

      <!-- A separate mic button just for debug view (different id) -->
      <div class="inline-field">
        <button class="btn" id="toggleMicDebug">Start listening (debug)</button>
      </div>
    </section>

    <!-- Debug -->
    <section class="stt-debug dev-only" aria-label="Speech recognition debug" id="sttDebug">
      <div class="stt-controls">
        <div class="inline-field">
          <label for="sttLang" class="muted">Recognition language</label>
          <select id="sttLang">
            <option value="en-GB" selected>English (UK)</option>
            <option value="en-US">English (US)</option>
            <option value="tr-TR">Türkçe</option>
          </select>
        </div>
        <label class="muted"><input type="checkbox" id="sttInterimChk" checked /> Show interim</label>
        <button class="btn ghost" id="sttClear" type="button">Clear logs</button>
      </div>

      <div class="stt-panels">
        <div class="stt-panel"><div class="stt-title">Final transcript</div><div id="sttFinal" class="stt-box"></div></div>
        <div class="stt-panel"><div class="stt-title">Interim transcript</div><div id="sttInterim" class="stt-box"></div></div>
        <div class="stt-panel"><div class="stt-title">Events</div><div id="sttEvents" class="stt-box monospace"></div></div>
      </div>

      <div class="stt-meter-row">
        <div class="stt-title">Mic level</div>
        <div class="stt-meter"><span id="sttMeterBar"></span></div>
        <button class="btn ghost" id="sttMicTest" type="button">Start mic test</button>
      </div>
    </section>

    <!-- Story -->
    <section class="story-reader">
      <h2 id="storyTitle" class="sr-only">Your story</h2>
      <div id="storyContent" class="story-content"></div>
    </section>
  </main>

  <footer>© <span id="year"></span> StoryBuds</footer>

  <script>
    /* =======================
       Load story + audio base
    ======================= */
    const SS = window.sessionStorage;
    const storyEl = document.getElementById("storyContent");
    storyEl.innerHTML = SS.getItem("yw_story_html") || '<p class="muted">No story found. Please generate a story first.</p>';

    // Show full controls in ?debug=1 mode
    const url = new URL(location.href);
    const isDebug = url.searchParams.get("debug") === "1";
    if (isDebug) {
      document.getElementById('soundbar')?.classList.remove('dev-only');
      document.getElementById('sttDebug')?.classList.remove('dev-only');
      // Nudge sticky CTA a bit higher when debug bars appear
      document.getElementById('toggleMic')?.style.setProperty('bottom','88px');
    }

    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const master = ctx.createGain(); master.gain.value = 0.35; master.connect(ctx.destination);
    // Volume slider may be hidden; guard listener
    (function(){
      const vol = document.getElementById('vol');
      if (vol) vol.addEventListener('input', e => { master.gain.value = parseFloat(e.target.value || "0.35"); });
    })();

    const deaccent = (s) => (s || "").normalize('NFD').replace(/\p{Diacritic}/gu, '').toLowerCase();

    /* ========= SFX ========= */
    function makeNoiseBuffer(){
      const b = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
      const d = b.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * 0.6;
      return b;
    }
    function playWhoosh(){
      const s = ctx.createBufferSource(); s.buffer = makeNoiseBuffer();
      const f = ctx.createBiquadFilter(); f.type = "lowpass"; f.frequency.value = 14000;
      const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.08);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.6);
      s.connect(f).connect(g).connect(master); s.start(); s.stop(ctx.currentTime + 0.65);
    }
    function playPlip(){
      const t = ctx.currentTime;
      [0, 0.18].forEach((d, i) => {
        const o = ctx.createOscillator(); o.type = "sine"; o.frequency.setValueAtTime(i ? 660 : 520, t + d);
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, t + d);
        g.gain.exponentialRampToValueAtTime(0.2, t + d + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + d + 0.25);
        o.connect(g).connect(master); o.start(t + d); o.stop(t + d + 0.26);
      });
    }
    function playChime(){
      const t = ctx.currentTime;
      [784, 988, 1319].forEach((f, i) => {
        const o = ctx.createOscillator(); o.type = "triangle"; o.frequency.setValueAtTime(f, t + i*0.08);
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, t + i*0.08);
        g.gain.exponentialRampToValueAtTime(0.22, t + i*0.08 + 0.04);
        g.gain.exponentialRampToValueAtTime(0.0001, t + i*0.08 + 0.6);
        o.connect(g).connect(master); o.start(t + i*0.08); o.stop(t + i*0.08 + 0.65);
      });
    }
    function playBarkSoft(){
      const t = ctx.currentTime;
      const o = ctx.createOscillator(); o.type = "square"; o.frequency.setValueAtTime(220, t);
      const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.15, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.2);
      o.connect(g).connect(master); o.start(t); o.stop(t + 0.21);
    }
    function playWindGust(){
      const s = ctx.createBufferSource(); s.buffer = makeNoiseBuffer();
      const bp = ctx.createBiquadFilter(); bp.type = "bandpass"; bp.frequency.value = 400; bp.Q.value = 0.7;
      const g = ctx.createGain(); g.gain.value = 0.0001;
      g.gain.exponentialRampToValueAtTime(0.18, ctx.currentTime + 0.06);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.8);
      s.connect(bp).connect(g).connect(master); s.start(); s.stop(ctx.currentTime + 0.85);
    }
    function playLullabyPhrase(){
      const t = ctx.currentTime;
      const g = ctx.createGain(); g.gain.value = 0.16; g.connect(master);
      const seq = [523.25, 523.25, 392.00, 440.00, 523.25];
      seq.forEach((f, i) => {
        const o = ctx.createOscillator(); o.type = "sine"; o.frequency.setValueAtTime(f, t + i*0.45);
        o.connect(g); o.start(t + i*0.45); o.stop(t + i*0.45 + 0.42);
      });
      setTimeout(() => { try { g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3); } catch(_){} }, 2400);
    }

    // Manual SFX (exists in DOM but hidden by default)
    (function(){
      const row = document.getElementById("manualSfx");
      if (!row) return;
      row.addEventListener("click", (e) => {
        const id = e.target.closest('[data-sfx]')?.dataset.sfx; if (!id) return;
        if (id === "whoosh")  return playWhoosh();
        if (id === "plip")    return playPlip();
        if (id === "chime")   return playChime();
        if (id === "bark")    return playBarkSoft();
        if (id === "wind")    return playWindGust();
        if (id === "lullaby") return playLullabyPhrase();
        if (id === "stop")    return stopAmbience();
      });
    })();

    /* ====== Ambience (auto + crossfade) ====== */
    let amb = { node: null, gain: null, kind: 'off' };

    function makeNoiseLoop(color='white'){
      const src = ctx.createBufferSource();
      const b = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
      const d = b.getChannelData(0);
      for (let i=0;i<d.length;i++){
        const white = Math.random()*2-1;
        d[i] = color === 'ocean' ? ((d[i-1]||0)*0.98 + white*0.02)
             : color === 'rain'  ? white*0.35
             : white*0.22;
      }
      src.buffer = b; src.loop = true;
      return src;
    }
    function makePad(freqs=[220, 277, 330]){
      const g = ctx.createGain(); g.gain.value = 0.0;
      freqs.forEach((f,i) => {
        const o = ctx.createOscillator(); o.type = 'sine';
        o.frequency.setValueAtTime(f, ctx.currentTime + i*0.03);
        const og = ctx.createGain(); og.gain.value = 0.06;
        o.connect(og).connect(g); o.start();
      });
      return { node: g, gain: g };
    }
    function startAmbience(kind){
      stopAmbience(0.5);
      let node=null, gain=null;
      if (kind === 'forest'){
        const s = makeNoiseLoop('white'); const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=900;
        const g = ctx.createGain(); g.gain.value = 0.0; s.connect(lp).connect(g).connect(master); s.start(); node=s; gain=g;
      } else if (kind === 'ocean'){
        const s = makeNoiseLoop('ocean'); const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=200; bp.Q.value=0.7;
        const g = ctx.createGain(); g.gain.value = 0.0; s.connect(bp).connect(g).connect(master); s.start(); node=s; gain=g;
      } else if (kind === 'rain'){
        const s = makeNoiseLoop('rain'); const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1800;
        const g = ctx.createGain(); g.gain.value = 0.0; s.connect(lp).connect(g).connect(master); s.start(); node=s; gain=g;
      } else if (kind === 'night'){
        const p = makePad([261.6, 329.6, 392.0]); p.node.connect(master); node=p.node; gain=p.gain;
      } else if (kind === 'castle'){
        const p = makePad([329.6, 415.3, 523.3]); p.node.connect(master); node=p.node; gain=p.gain;
      } else if (kind === 'pad'){
        const p = makePad([220, 277, 330]); p.node.connect(master); node=p.node; gain=p.gain;
      }
      if (gain){
        const t = ctx.currentTime;
        gain.gain.cancelScheduledValues(t);
        gain.gain.linearRampToValueAtTime(0.0, t);
        gain.gain.linearRampToValueAtTime(0.14, t + 0.8);
      }
      amb = { node, gain, kind };
    }
    function stopAmbience(fade=0.3){
      if (!amb.gain){ amb = { node:null, gain:null, kind:'off' }; return; }
      const t = ctx.currentTime;
      amb.gain.gain.cancelScheduledValues(t);
      amb.gain.gain.linearRampToValueAtTime(0, t + fade);
      if (amb.node && amb.node.stop) amb.node.stop(t + fade + 0.05);
      amb = { node:null, gain:null, kind:'off' };
    }

    const ambSel = document.getElementById('amb');
    function pickAmbienceFromStory(text){
      const s = deaccent(text || '');
      if (/\brain|storm|puddle/.test(s)) return 'rain';
      if (/\bocean|sea|wave|beach/.test(s)) return 'ocean';
      if (/\bforest|woods|tree|owl/.test(s)) return 'forest';
      if (/\bnight|moon|sleep|star/.test(s)) return 'night';
      if (/\bcastle|king|queen|magic/.test(s)) return 'castle';
      return 'pad';
    }
    function applyAmbienceSelection(val){
      if (val === 'off') return stopAmbience(0.4);
      if (val === 'auto') return startAmbience(pickAmbienceFromStory(storyEl.textContent || ''));
      startAmbience(val);
    }
    const storedAmb = SS.getItem("yw_ambience") || "auto";
    if (ambSel) {
      ambSel.value = storedAmb;
      applyAmbienceSelection(ambSel.value);
      ambSel.addEventListener('change', e => {
        const v = e.target.value;
        SS.setItem("yw_ambience", v);
        applyAmbienceSelection(v);
      });
    } else {
      applyAmbienceSelection(storedAmb);
    }

    /* ==========================================
       Option 1: Story follower + prefix trigger
       ========================================== */
    const RAW_TEXT = (storyEl.textContent || "")
      .toLowerCase()
      .normalize('NFD').replace(/\p{Diacritic}/gu,'')
      .replace(/[^a-z0-9\s']/g,' ')
      .replace(/\s+/g,' ')
      .trim();

    const TRIGGERS = new Set(['magic','sparkle','rain','wind','dog','puppy','star','sleep','fly']);
    const EFFECT_FOR = {
      magic:'chime', sparkle:'chime', star:'chime',
      rain:'plip', wind:'wind', dog:'bark', puppy:'bark',
      sleep:'lullaby', fly:'whoosh'
    };

    const TOKENS = RAW_TEXT ? RAW_TEXT.split(' ') : [];
    let cursor = 0;
    const MIN_PREFIX = (w) => Math.min(3, Math.max(2, Math.floor(w.length * 0.35)));

    let lastEffectAt = 0;
    const COOLDOWN_GLOBAL_MS = 380;
    const lastAtByEffect = Object.create(null);
    function canTrigger(effectName, cdMs){
      const now = Date.now();
      if (now - lastEffectAt < COOLDOWN_GLOBAL_MS) return false;
      const last = lastAtByEffect[effectName] || 0;
      if (now - last < cdMs) return false;
      lastAtByEffect[effectName] = now;
      lastEffectAt = now;
      return true;
    }
    const EFFECTS = {
      whoosh: { fn: playWhoosh,       cd: 1600 },
      plip:   { fn: playPlip,         cd: 1600 },
      wind:   { fn: playWindGust,     cd: 5000 },
      chime:  { fn: playChime,        cd: 2500 },
      bark:   { fn: playBarkSoft,     cd: 2200 },
      lullaby:{ fn: playLullabyPhrase,cd: 7000 },
    };
    function triggerEffect(name){
      const eff = EFFECTS[name];
      if (!eff) return;
      if (canTrigger(name, eff.cd)) eff.fn();
    }

    function alignAndMaybeTrigger(interimTail) {
      if (!TOKENS.length) return;
      const words = interimTail.toLowerCase().split(/\s+/).filter(Boolean).slice(-12);
      if (!words.length) return;

      const WINDOW = 30;
      let bestIdx = cursor, bestHit = 0;
      const start = Math.max(0, cursor - WINDOW);
      const end   = Math.min(TOKENS.length, cursor + WINDOW);

      for (let i = start; i < end; i++) {
        const sliceStart = Math.max(0, i - words.length + 1);
        const slice = TOKENS.slice(sliceStart, i + 1);
        let hit = 0;
        const offset = Math.max(0, words.length - slice.length);
        for (let k = 0; k < slice.length; k++) if (slice[k] === words[offset + k]) hit++;
        if (hit > bestHit) { bestHit = hit; bestIdx = i; }
      }

      if (bestIdx > cursor) cursor = Math.min(bestIdx, cursor + 3);

      for (let j = cursor; j < Math.min(cursor + 20, TOKENS.length); j++) {
        const w = TOKENS[j];
        if (!TRIGGERS.has(w)) continue;

        const need   = MIN_PREFIX(w);
        const prefix = w.slice(0, need);
        const lastWord = words[words.length - 1] || '';

        if (lastWord.startsWith(prefix)) {
          const eff = EFFECT_FOR[w];
          if (eff) triggerEffect(eff);
          cursor = Math.min(j + 1, TOKENS.length - 1);
          break;
        }
        if (j - cursor > 8) break;
      }
    }

    /* ====== Speech Recognition (low-latency interim + follower) ====== */
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;

    // Prefer the production sticky button; fall back to the debug one if present
    const micBtn = document.getElementById('toggleMic') || document.getElementById('toggleMicDebug');
    const micStatus = document.getElementById('micStatus');
    const langSel   = document.getElementById('sttLang');
    const interimChk= document.getElementById('sttInterimChk');
    const boxFinal  = document.getElementById('sttFinal');
    const boxInter  = document.getElementById('sttInterim');
    const boxEv     = document.getElementById('sttEvents');

    function logEv(msg){
      const t = new Date().toLocaleTimeString();
      if (boxEv) {
        boxEv.textContent += `[${t}] ${msg}\n`;
        boxEv.scrollTop = boxEv.scrollHeight;
      }
    }

    let micPrimed = false;
    async function ensureMicPermission() {
      if (micPrimed) return;
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:true, noiseSuppression:true }
      });
      stream.getTracks().forEach(t => t.stop());
      micPrimed = true;
    }

    const effectMatchers = [
      { name:'whoosh',  rx:/\b(fly|whoosh|soar(?:ed)?|uçtu|r[üu]zgar)\b/iu },
      { name:'plip',    rx:/\b(rain|raindrop|raindrops|plip(?:-?plop)?|shower|ya[ğg]mur)\b/iu },
      { name:'wind',    rx:/\b(wind|breeze|forest|a[gğ]a[cç])\b/iu },
      { name:'chime',   rx:/\b(magic|sparkle|sparkly|sparkles|star[s]?|parlad[ıi]|sihir)\b/iu },
      { name:'bark',    rx:/\b(dog|puppy|papi|poppy|bark|k[öo]pek)\b/iu },
      { name:'lullaby', rx:/\b(good\s*night|sleep|yawn|uyku|iyi\s*geceler)\b/iu },
    ];
    function scanAndTriggerFree(text){
      const clean = deaccent(text);
      for (const {name, rx} of effectMatchers){ if (rx.test(clean)) { triggerEffect(name); break; } }
    }

    let interimWindow = "";
    const MAX_WINDOW_CHARS = 200;
    let debounceTimer = null;
    let lastTokenSeen = "";
    let rec = null;

    async function startMic(){
      if (!SpeechRec){
        if (micStatus) micStatus.textContent = 'Microphone: unsupported in this browser';
        logEv('SpeechRecognition not available');
        return;
      }

      if (micBtn) micBtn.disabled = true;
      try {
        if (ctx.state !== 'running') await ctx.resume();
        await ensureMicPermission();

        const lang = (langSel?.value || 'en-GB');
        rec = new SpeechRec();
        rec.lang = lang;
        rec.continuous = true;
        rec.interimResults = true;
        rec.maxAlternatives = 1;

        rec.onstart = () => {
          if (micStatus) micStatus.textContent = `Microphone: listening… (${lang})`;
          if (micBtn) { micBtn.textContent = 'Stop listening'; micBtn.disabled = false; }
          logEv('onstart');
        };
        rec.onresult = (e) => {
          const finals=[], interims=[];
          for (let i=e.resultIndex; i<e.results.length; i++){
            const r = e.results[i]; const t = r[0]?.transcript || '';
            (r.isFinal ? finals : interims).push(t);
          }

          const interimText = interims.join(' ').trim();
          if (boxInter) boxInter.textContent = (interimChk?.checked ? interimText : '');
          if (interimText) {
            const toks = interimText.trim().split(/\s+/).slice(-6);
            const lastTok = toks[toks.length - 1] || "";
            if (lastTok && lastTok !== lastTokenSeen) {
              lastTokenSeen = lastTok;
              scanAndTriggerFree(lastTok);
            }
            alignAndMaybeTrigger(interimText);
            interimWindow = (interimWindow + ' ' + interimText).slice(-MAX_WINDOW_CHARS);
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => alignAndMaybeTrigger(interimWindow), 60);
          }

          if (finals.length){
            const finalText = finals.join(' ').trim();
            if (finalText){
              if (boxFinal) {
                boxFinal.textContent += (boxFinal.textContent ? '\n' : '') + finalText;
                boxFinal.scrollTop = boxFinal.scrollHeight;
              }
              logEv(`final: "${finalText}"`);
              scanAndTriggerFree(finalText);
              alignAndMaybeTrigger(finalText);
            }
            interimWindow = '';
            if (boxInter) boxInter.textContent = '';
          }
        };
        rec.onerror = (e) => logEv(`onerror: ${e?.error || 'unknown'}`);
        rec.onend   = () => {
          logEv('onend');
          if (micStatus) micStatus.textContent = 'Microphone: idle';
          if (micBtn) { micBtn.textContent = 'Start listening'; micBtn.onclick = startMic; micBtn.disabled = false; }
        };

        if (micBtn) micBtn.onclick = stopMic;
        rec.start();
      } catch (err) {
        logEv(`startMic() error: ${err?.message || err}`);
        if (micStatus) micStatus.textContent = 'Microphone: idle';
        if (micBtn) { micBtn.textContent = 'Start listening'; micBtn.onclick = startMic; micBtn.disabled = false; }
      }
    }

    function stopMic(){
      try { rec && rec.stop && rec.stop(); } catch(_) {}
      // UI resets in onend
    }

    if (micBtn) micBtn.onclick = startMic;

    (function(){
      const clearBtn = document.getElementById("sttClear");
      if (!clearBtn) return;
      clearBtn.addEventListener("click", () => {
        const boxFinal  = document.getElementById('sttFinal');
        const boxInter  = document.getElementById('sttInterim');
        const boxEv     = document.getElementById('sttEvents');
        if (boxFinal) boxFinal.textContent='';
        if (boxInter) boxInter.textContent='';
        if (boxEv)    boxEv.textContent='';
      });
    })();

    (function(){
      const meterBar = document.getElementById("sttMeterBar");
      const btn = document.getElementById("sttMicTest");
      if (!btn || !meterBar) return;
      btn.addEventListener("click", async () => {
        try{
          const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true } });
          const src = ctx.createMediaStreamSource(stream);
          const analyser = ctx.createAnalyser(); analyser.fftSize = 512; src.connect(analyser);
          const data = new Uint8Array(analyser.fftSize);
          (function loop(){
            analyser.getByteTimeDomainData(data);
            let sum=0; for (let i=0;i<data.length;i++){ const d=data[i]-128; sum+=d*d; }
            const rms = Math.sqrt(sum/data.length);
            const pct = Math.min(100, Math.max(0, (rms/35)*100));
            meterBar.style.width = pct.toFixed(0) + '%';
            requestAnimationFrame(loop);
          })();
          logEv('Mic test running — speak and watch the bar');
        } catch(err){ logEv('Mic test error: ' + (err?.message || err)); }
      });
    })();

    // One-time resume for mobile autoplay policies
    document.body.addEventListener("click", () => ctx.resume && ctx.resume(), { once:true });
    document.getElementById("year").textContent = new Date().getFullYear();
  </script>
</body>
</html>
