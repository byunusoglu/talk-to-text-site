<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Your Story — Read with Sounds (Beta) | StoryBuds</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800&family=Inter:wght@400;600&family=Alegreya:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css" />
  <script defer src="script.js"></script>

  <style>
    /* === Local layout polish === */
    .detail-wrap { max-width: 980px; margin: 20px auto; padding: 0 16px; }
    .soundbar {
      position: sticky; top: 68px; z-index: 10;
      display: grid; grid-template-columns: 1fr auto auto auto; gap: 8px;
      align-items: center; background: rgba(255,255,255,0.9);
      border: 1px solid #eee9fb; border-radius: 14px; padding: 10px 12px;
      box-shadow: var(--shadow);
    }
    .soundbar .status { color: #3a3450; font-weight: 600; }
    .soundbar .hint   { color: var(--muted); font-size: 13px; }
    .sfx-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .sfx-row .btn { padding: 10px 14px; font-weight: 700; }
    .inline-field { display:flex; align-items:center; gap:8px; }
    .inline-field input[type="range"] { width: 160px; }
    .story-reader { margin-top: 16px; }
    .badge-beta { display:inline-block; margin-left:6px; font-size:12px; font-weight:800; padding:2px 8px; border-radius:999px; background:#fbf9ff; border:1px solid #eee9fb; color: var(--plum-dark); }

    /* === STT Debug Panel === */
    .stt-debug { margin-top:12px; border:1px solid #eee9fb; border-radius:14px; background:rgba(255,255,255,0.9); box-shadow:var(--shadow); padding:12px; }
    .stt-controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
    .stt-panels { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
    .stt-panel { display:flex; flex-direction:column; gap:6px; }
    .stt-title { font-weight:700; color:#3a3450; font-size:14px; }
    .stt-box { min-height:80px; padding:10px; border:1px solid #eee9fb; border-radius:10px; background:#fff; overflow:auto; }
    .monospace { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap; }
    .stt-meter-row { display:flex; align-items:center; gap:12px; margin-top:10px; }
    .stt-meter { flex:1; height:10px; background:#f2f2f6; border-radius:999px; overflow:hidden; border:1px solid #eee9fb; }
    .stt-meter span { display:block; height:100%; width:0%; background:#8E44EC; transition: width .08s linear; }

    /* small helper badge for KWS status */
    .kws-pill { display:inline-block; padding:4px 10px; border-radius:999px; border:1px solid #eee9fb; background:#fbf9ff; color:#6C2E9C; font-weight:800; font-size:12px; }
    .kws-pill.on { background:#eaf8f1; color:#055a35; border-color:#d6efe3; }

    @media (max-width:900px){
      .soundbar{ grid-template-columns:1fr; }
      .stt-panels{ grid-template-columns:1fr; }
    }
  </style>
</head>

<body class="fade-in">
  <!-- Topbar -->
  <header class="topbar">
    <a href="index.html" class="logo">
      <span class="logo-badge"><img src="logo.png" alt="StoryBuds logo" /></span>
    </a>
    <div class="top-actions">
      <button class="cart-btn" id="cartBtn" aria-label="Cart">
        <svg class="cart-icon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M3 3h2l3.6 9.59a1 1 0 0 0 .92.65H17a1 1 0 0 0 .96-.74L20 6H6"
                stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="9" cy="20" r="1" fill="currentColor"></circle>
          <circle cx="17" cy="20" r="1" fill="currentColor"></circle>
        </svg>
        <span class="cart-count" id="cartCount">0</span>
      </button>
      <button class="hamburger" id="menuBtn" aria-label="Menu">☰</button>
    </div>
    <nav id="menu" class="menu hidden" aria-label="Main navigation">
      <a href="home.html">Home</a>
      <a href="create.html">Create Stories</a>
      <a href="#">My Profile</a>
    </nav>
  </header>

  <main class="detail-wrap">
    <h1>Read with Sounds <span class="badge-beta">Beta</span></h1>

    <!-- Controls -->
    <section class="soundbar">
      <div>
        <div class="status" id="micStatus">Microphone: off</div>
        <div class="hint" id="micHint">Tap “Start listening” and read the story aloud.</div>
        <div class="sfx-row" id="manualSfx">
          <button class="btn ghost" data-sfx="whoosh">Whoosh</button>
          <button class="btn ghost" data-sfx="plip">Plip-plop</button>
          <button class="btn ghost" data-sfx="wind">Wind</button>
          <button class="btn ghost" data-sfx="chime">Magic chime</button>
          <button class="btn ghost" data-sfx="bark">Puppy bark (soft)</button>
          <button class="btn ghost" data-sfx="lullaby">Lullaby (phrase)</button>
          <button class="btn ghost" data-sfx="stop">Stop ambience</button>
        </div>
      </div>

      <!-- Volume -->
      <div class="inline-field">
        <label for="vol" class="muted">Volume</label>
        <input id="vol" type="range" min="0" max="1" step="0.01" value="0.35" />
      </div>

      <!-- Ambience -->
      <div class="inline-field">
        <label for="amb" class="muted">Ambience</label>
        <select id="amb">
          <option value="auto" selected>Auto</option>
          <option value="forest">Forest</option>
          <option value="ocean">Ocean</option>
          <option value="night">Night</option>
          <option value="castle">Castle</option>
          <option value="rain">Rain</option>
          <option value="pad">Calm Pad</option>
          <option value="off">Off</option>
        </select>
      </div>

      <div class="inline-field">
        <button class="btn" id="toggleMic">Start listening</button>
      </div>
    </section>

    <!-- Debug -->
    <section class="stt-debug" aria-label="Speech recognition debug">
      <div class="stt-controls">
        <div class="inline-field">
          <label for="sttLang" class="muted">Recognition language</label>
          <select id="sttLang">
            <option value="en-GB" selected>English (UK)</option>
            <option value="en-US">English (US)</option>
            <option value="tr-TR">Türkçe</option>
          </select>
        </div>

        <label class="muted"><input type="checkbox" id="sttInterimChk" checked /> Show interim</label>

        <button class="btn ghost" id="sttClear" type="button">Clear logs</button>

        <!-- Optional Keyword Spotter toggle -->
        <button class="btn ghost" id="kwsToggle" type="button">Enable Keyword Spotter</button>
        <span id="kwsStatus" class="kws-pill" aria-live="polite">KWS: Off</span>
      </div>

      <div class="stt-panels">
        <div class="stt-panel"><div class="stt-title">Final transcript</div><div id="sttFinal" class="stt-box"></div></div>
        <div class="stt-panel"><div class="stt-title">Interim transcript</div><div id="sttInterim" class="stt-box"></div></div>
        <div class="stt-panel"><div class="stt-title">Events</div><div id="sttEvents" class="stt-box monospace"></div></div>
      </div>

      <div class="stt-meter-row">
        <div class="stt-title">Mic level</div>
        <div class="stt-meter"><span id="sttMeterBar"></span></div>
        <button class="btn ghost" id="sttMicTest" type="button">Start mic test</button>
      </div>
    </section>

    <!-- Story -->
    <section class="story-reader">
      <h2 id="storyTitle" class="sr-only">Your story</h2>
      <div id="storyContent" class="story-content"></div>
    </section>
  </main>

  <footer>© <span id="year"></span> StoryBuds</footer>

  <script>
    /* =======================
       Load story + audio base
    ======================= */
    const SS = window.sessionStorage;
    const storyEl = document.getElementById("storyContent");
    storyEl.innerHTML = SS.getItem("yw_story_html") || '<p class="muted">No story found. Please generate a story first.</p>';

    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const master = ctx.createGain(); master.gain.value = 0.35; master.connect(ctx.destination);
    document.getElementById('vol').addEventListener('input', e => { master.gain.value = parseFloat(e.target.value || "0.35"); });

    const deaccent = (s) => (s || "").normalize('NFD').replace(/\p{Diacritic}/gu, '').toLowerCase();

    /* ========= SFX ========= */
    function makeNoiseBuffer(){
      const b = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
      const d = b.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * 0.6;
      return b;
    }
    function playWhoosh(){
      const s = ctx.createBufferSource(); s.buffer = makeNoiseBuffer();
      const f = ctx.createBiquadFilter(); f.type = "lowpass"; f.frequency.value = 14000;
      const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.3, ctx.currentTime + 0.08);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.6);
      s.connect(f).connect(g).connect(master); s.start(); s.stop(ctx.currentTime + 0.65);
    }
    function playPlip(){
      const t = ctx.currentTime;
      [0, 0.18].forEach((d, i) => {
        const o = ctx.createOscillator(); o.type = "sine"; o.frequency.setValueAtTime(i ? 660 : 520, t + d);
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, t + d);
        g.gain.exponentialRampToValueAtTime(0.2, t + d + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + d + 0.25);
        o.connect(g).connect(master); o.start(t + d); o.stop(t + d + 0.26);
      });
    }
    function playChime(){
      const t = ctx.currentTime;
      [784, 988, 1319].forEach((f, i) => {
        const o = ctx.createOscillator(); o.type = "triangle"; o.frequency.setValueAtTime(f, t + i*0.08);
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, t + i*0.08);
        g.gain.exponentialRampToValueAtTime(0.22, t + i*0.08 + 0.04);
        g.gain.exponentialRampToValueAtTime(0.0001, t + i*0.08 + 0.6);
        o.connect(g).connect(master); o.start(t + i*0.08); o.stop(t + i*0.08 + 0.65);
      });
    }
    function playBarkSoft(){
      const t = ctx.currentTime;
      const o = ctx.createOscillator(); o.type = "square"; o.frequency.setValueAtTime(220, t);
      const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.15, t + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.2);
      o.connect(g).connect(master); o.start(t); o.stop(t + 0.21);
    }
    function playWindGust(){
      const s = ctx.createBufferSource(); s.buffer = makeNoiseBuffer();
      const bp = ctx.createBiquacFilter ? ctx.createBiquacFilter() : ctx.createBiquadFilter();
      bp.type = "bandpass"; bp.frequency.value = 400; bp.Q.value = 0.7;
      const g = ctx.createGain(); g.gain.value = 0.0001;
      g.gain.exponentialRampToValueAtTime(0.18, ctx.currentTime + 0.06);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.8);
      s.connect(bp).connect(g).connect(master); s.start(); s.stop(ctx.currentTime + 0.85);
    }
    function playLullabyPhrase(){
      const t = ctx.currentTime;
      const g = ctx.createGain(); g.gain.value = 0.16; g.connect(master);
      const seq = [523.25, 523.25, 392.00, 440.00, 523.25];
      seq.forEach((f, i) => {
        const o = ctx.createOscillator(); o.type = "sine"; o.frequency.setValueAtTime(f, t + i*0.45);
        o.connect(g); o.start(t + i*0.45); o.stop(t + i*0.45 + 0.42);
      });
      setTimeout(() => { try { g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3); } catch(_){} }, 2400);
    }

    // Manual SFX
    document.getElementById("manualSfx").addEventListener("click", (e) => {
      const id = e.target.closest('[data-sfx]')?.dataset.sfx; if (!id) return;
      if (id === "whoosh")  return playWhoosh();
      if (id === "plip")    return playPlip();
      if (id === "chime")   return playChime();
      if (id === "bark")    return playBarkSoft();
      if (id === "wind")    return playWindGust();
      if (id === "lullaby") return playLullabyPhrase();
      if (id === "stop")    return stopAmbience();
    });

    /* ====== Ambience (auto + crossfade) ====== */
    let amb = { node: null, gain: null, kind: 'off' };

    function makeNoiseLoop(color='white'){
      const src = ctx.createBufferSource();
      const b = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
      const d = b.getChannelData(0);
      for (let i=0;i<d.length;i++){
        const white = Math.random()*2-1;
        d[i] = color === 'ocean' ? ((d[i-1]||0)*0.98 + white*0.02)
             : color === 'rain'  ? white*0.35
             : white*0.22;
      }
      src.buffer = b; src.loop = true;
      return src;
    }
    function makePad(freqs=[220, 277, 330]){
      const g = ctx.createGain(); g.gain.value = 0.0;
      freqs.forEach((f,i) => {
        const o = ctx.createOscillator(); o.type = 'sine';
        o.frequency.setValueAtTime(f, ctx.currentTime + i*0.03);
        const og = ctx.createGain(); og.gain.value = 0.06;
        o.connect(og).connect(g); o.start();
      });
      return { node: g, gain: g };
    }
    function startAmbience(kind){
      stopAmbience(0.5);
      let node=null, gain=null;
      if (kind === 'forest'){
        const s = makeNoiseLoop('white'); const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=900;
        const g = ctx.createGain(); g.gain.value = 0.0; s.connect(lp).connect(g).connect(master); s.start(); node=s; gain=g;
      } else if (kind === 'ocean'){
        const s = makeNoiseLoop('ocean'); const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=200; bp.Q.value=0.7;
        const g = ctx.createGain(); g.gain.value = 0.0; s.connect(bp).connect(g).connect(master); s.start(); node=s; gain=g;
      } else if (kind === 'rain'){
        const s = makeNoiseLoop('rain'); const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1800;
        const g = ctx.createGain(); g.gain.value = 0.0; s.connect(lp).connect(g).connect(master); s.start(); node=s; gain=g;
      } else if (kind === 'night'){
        const p = makePad([261.6, 329.6, 392.0]); p.node.connect(master); node=p.node; gain=p.gain;
      } else if (kind === 'castle'){
        const p = makePad([329.6, 415.3, 523.3]); p.node.connect(master); node=p.node; gain=p.gain;
      } else if (kind === 'pad'){
        const p = makePad([220, 277, 330]); p.node.connect(master); node=p.node; gain=p.gain;
      }
      if (gain){
        const t = ctx.currentTime;
        gain.gain.cancelScheduledValues(t);
        gain.gain.linearRampToValueAtTime(0.0, t);
        gain.gain.linearRampToValueAtTime(0.14, t + 0.8);
      }
      amb = { node, gain, kind };
    }
    function stopAmbience(fade=0.3){
      if (!amb.gain){ amb = { node:null, gain:null, kind:'off' }; return; }
      const t = ctx.currentTime;
      amb.gain.gain.cancelScheduledValues(t);
      amb.gain.gain.linearRampToValueAtTime(0, t + fade);
      if (amb.node && amb.node.stop) amb.node.stop(t + fade + 0.05);
      amb = { node:null, gain:null, kind:'off' };
    }

    const ambSel = document.getElementById('amb');
    function pickAmbienceFromStory(text){
      const s = deaccent(text || '');
      if (/\brain|storm|puddle/.test(s)) return 'rain';
      if (/\bocean|sea|wave|beach/.test(s)) return 'ocean';
      if (/\bforest|woods|tree|owl/.test(s)) return 'forest';
      if (/\bnight|moon|sleep|star/.test(s)) return 'night';
      if (/\bcastle|king|queen|magic/.test(s)) return 'castle';
      return 'pad';
    }
    function applyAmbienceSelection(val){
      if (val === 'off') return stopAmbience(0.4);
      if (val === 'auto') return startAmbience(pickAmbienceFromStory(storyEl.textContent || ''));
      startAmbience(val);
    }
    applyAmbienceSelection('auto');
    ambSel.addEventListener('change', e => applyAmbienceSelection(e.target.value));

    /* ====== Speech Recognition (interim + final with cooldowns) ====== */
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
    const micBtn    = document.getElementById('toggleMic');
    const micStatus = document.getElementById('micStatus');
    const langSel   = document.getElementById('sttLang');
    const interimChk= document.getElementById('sttInterimChk');
    const boxFinal  = document.getElementById('sttFinal');
    const boxInter  = document.getElementById('sttInterim');
    const boxEv     = document.getElementById('sttEvents');
    const btnClear  = document.getElementById('sttClear');

    let rec = null, active = false;
    function logEv(msg){ const t = new Date().toLocaleTimeString(); boxEv.textContent += `[${t}] ${msg}\n`; boxEv.scrollTop = boxEv.scrollHeight; }

    // effects and regexes (for both SR & KWS mapping)
    const EFFECTS = {
      whoosh: { fn: playWhoosh, cd: 1600 },
      plip:   { fn: playPlip,   cd: 1600 },
      wind:   { fn: playWindGust, cd: 5000 },
      chime:  { fn: playChime,  cd: 2500 },
      bark:   { fn: playBarkSoft, cd: 2200 },
      lullaby:{ fn: playLullabyPhrase, cd: 7000 },
    };
    const effectMatchers = [
      { name:'whoosh',  rx:/\b(fly|whoosh|soar(?:ed)?|uçtu|r[üu]zgar)\b/iu },
      { name:'plip',    rx:/\b(rain|raindrop|raindrops|plip(?:-?plop)?|shower|ya[ğg]mur)\b/iu },
      { name:'wind',    rx:/\b(wind|breeze|forest|a[gğ]a[cç])\b/iu },
      { name:'chime',   rx:/\b(magic|sparkle|sparkly|sparkles|star[s]?|parlad[ıi]|sihir)\b/iu },
      { name:'bark',    rx:/\b(dog|puppy|papi|poppy|bark|k[öo]pek)\b/iu },
      { name:'lullaby', rx:/\b(good\s*night|sleep|yawn|uyku|iyi\s*geceler)\b/iu },
    ];

    // cooldowns
    let lastEffectAt = 0;
    const COOLDOWN_GLOBAL_MS = 380;
    const lastAtByEffect = Object.create(null);
    function canTrigger(effectName, cdMs){
      const now = Date.now();
      if (now - lastEffectAt < COOLDOWN_GLOBAL_MS) return false;
      const last = lastAtByEffect[effectName] || 0;
      if (now - last < cdMs) return false;
      lastAtByEffect[effectName] = now;
      lastEffectAt = now;
      return true;
    }

    // interim window (low-latency)
    let interimWindow = "";
    const MAX_WINDOW_CHARS = 200;
    let debounceTimer = null;
    let lastTokenSeen = "";

    function triggerEffect(name){
      const eff = EFFECTS[name];
      if (!eff) return;
      if (canTrigger(name, eff.cd)) eff.fn();
    }
    function scanAndTrigger(text){
      const clean = deaccent(text);
      for (const {name, rx} of effectMatchers){
        if (rx.test(clean)) { triggerEffect(name); break; }
      }
    }

    function startMic(){
      if (!SpeechRec){ micStatus.textContent = 'Microphone: unsupported in this browser'; logEv('SpeechRecognition not available'); return; }
      if (active) return;

      const lang = (langSel?.value || 'en-GB');
      rec = new SpeechRec();
      rec.lang = lang;
      rec.continuous = true;
      rec.interimResults = true;
      rec.maxAlternatives = 1;

      rec.onstart = () => { active = true; micStatus.textContent = `Microphone: listening… (${lang})`; micBtn.textContent = 'Stop listening'; logEv('onstart'); };
      rec.onresult = (e) => {
        const finals=[], interims=[];
        for (let i=e.resultIndex; i<e.results.length; i++){
          const r = e.results[i]; const t = r[0]?.transcript || '';
          (r.isFinal ? finals : interims).push(t);
        }

        // Interim (live, token-first)
        const interimText = interims.join(' ').trim();
        boxInter.textContent = (interimChk?.checked ? interimText : '');
        if (interimText) {
          const toks = interimText.trim().split(/\s+/).slice(-6);
          const lastTok = toks[toks.length - 1] || "";
          if (lastTok && lastTok !== lastTokenSeen) {
            lastTokenSeen = lastTok;
            scanAndTrigger(lastTok); // react to newest token
          }
          interimWindow = (interimWindow + ' ' + interimText).slice(-MAX_WINDOW_CHARS);
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => scanAndTrigger(interimWindow), 80);
        }

        // Final (commit)
        if (finals.length){
          const finalText = finals.join(' ').trim();
          if (finalText){
            boxFinal.textContent += (boxFinal.textContent ? '\n' : '') + finalText;
            boxFinal.scrollTop = boxFinal.scrollHeight;
            logEv(`final: "${finalText}"`);
            scanAndTrigger(finalText);
          }
          interimWindow = '';
          boxInter.textContent = '';
        }
      };
      rec.onerror = (e) => logEv(`onerror: ${e?.error || 'unknown'}`);
      rec.onend   = () => { logEv('onend'); if (active) { try { rec.start(); } catch(_) {} } };
      try { rec.start(); } catch(err) { logEv(`start() error: ${err?.message || err}`); }
    }

    function stopMic(){
      active = false;
      try { rec && rec.stop(); } catch(_) {}
      rec = null;
      micStatus.textContent = 'Microphone: off';
      micBtn.textContent = 'Start listening';
      clearTimeout(debounceTimer);
    }

    document.getElementById("toggleMic").addEventListener("click", () => active ? stopMic() : startMic());
    document.getElementById("sttClear").addEventListener("click", () => { boxFinal.textContent=''; boxInter.textContent=''; boxEv.textContent=''; });

    // Mic level test
    const meterBar = document.getElementById("sttMeterBar");
    document.getElementById("sttMicTest").addEventListener("click", async () => {
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true } });
        const src = ctx.createMediaStreamSource(stream);
        const analyser = ctx.createAnalyser(); analyser.fftSize = 512; src.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);
        (function loop(){
          analyser.getByteTimeDomainData(data);
          let sum=0; for (let i=0;i<data.length;i++){ const d=data[i]-128; sum+=d*d; }
          const rms = Math.sqrt(sum/data.length);
          const pct = Math.min(100, Math.max(0, (rms/35)*100));
          meterBar.style.width = pct.toFixed(0) + '%';
          requestAnimationFrame(loop);
        })();
        logEv('Mic test running — speak and watch the bar');
      } catch(err){ logEv('Mic test error: ' + (err?.message || err)); }
    });

    // One-time resume for mobile autoplay policies
    document.body.addEventListener("click", () => ctx.resume && ctx.resume(), { once:true });
    document.getElementById("year").textContent = new Date().getFullYear();

    /* ===========================
       OPTIONAL: Keyword Spotter
       ===========================
       This block auto-enables low-latency KWS if a compatible SDK is present.
       It does NOT break anything if the SDK is missing.
       Steps (when you're ready):
       1) Include your KWS SDK script tag in <head> (e.g., Porcupine Web).
       2) Provide ACCESS_KEY and keyword model URLs below.
       3) Click "Enable Keyword Spotter" in the debug panel.
    */
    const kwsBtn = document.getElementById('kwsToggle');
    const kwsStatus = document.getElementById('kwsStatus');
    let kwsEngine = null;
    let kwsOn = false;

    // Map KWS detections → our effect names
    const KWS_MAP = {
      magic: 'chime',
      sparkle: 'chime',
      star: 'chime',
      rain: 'plip',
      wind: 'wind',
      dog: 'bark',
      sleep: 'lullaby',
      fly: 'whoosh'
    };

    async function initKwsIfAvailable(){
      if (kwsEngine) return kwsEngine;

      // TODO: If using Porcupine Web SDK, ensure it’s loaded globally (window.PorcupineWeb).
      // If not present, we just return null and keep using SR fallback.
      if (!window.PorcupineWeb) return null;

      // TODO: put your real access key here
      const ACCESS_KEY = "YOUR_PORCUPINE_ACCESS_KEY";

      // TODO: map your keyword labels to .ppn URLs you host/cdn.
      // You can start with 4–6 core words you want instant reactions for.
      const KEYWORDS = {
        magic:   "https://yourcdn.example.com/kws/magic_en.ppn",
        sparkle: "https://yourcdn.example.com/kws/sparkle_en.ppn",
        star:    "https://yourcdn.example.com/kws/star_en.ppn",
        rain:    "https://yourcdn.example.com/kws/rain_en.ppn",
        wind:    "https://yourcdn.example.com/kws/wind_en.ppn",
        dog:     "https://yourcdn.example.com/kws/dog_en.ppn",
        sleep:   "https://yourcdn.example.com/kws/sleep_en.ppn",
        fly:     "https://yourcdn.example.com/kws/fly_en.ppn"
      };

      try {
        // Example initialization pattern (Porcupine Web style API).
        // Adjust to your chosen SDK’s API.
        const p = await PorcupineWeb.create(ACCESS_KEY, Object.values(KEYWORDS));
        // Wrap a small adapter so we know which keyword fired:
        const labels = Object.keys(KEYWORDS);
        kwsEngine = {
          start: async () => {
            const mic = await PorcupineWeb.MicrophoneRecorder.create(p);
            mic.start();
            // Polling callback:
            mic.setOnFrameProcessed((keywordIndex) => {
              if (keywordIndex >= 0) {
                const label = labels[keywordIndex];
                const eff = KWS_MAP[label];
                if (eff) triggerEffect(eff);
                logEv(`KWS: ${label}`);
              }
            });
          },
          stop: async () => { try { await PorcupineWeb.MicrophoneRecorder.stop(); } catch(_){} }
        };
        return kwsEngine;
      } catch (err) {
        logEv('KWS init failed: ' + (err?.message || err));
        return null;
      }
    }

    kwsBtn.addEventListener('click', async () => {
      if (!kwsOn) {
        kwsBtn.disabled = true;
        const engine = await initKwsIfAvailable();
        kwsBtn.disabled = false;
        if (!engine) {
          logEv('KWS not available (no SDK or init error). Staying on SR fallback.');
          kwsStatus.textContent = 'KWS: Off';
          kwsStatus.classList.remove('on');
          return;
        }
        await engine.start();
        kwsOn = true;
        kwsStatus.textContent = 'KWS: On';
        kwsStatus.classList.add('on');
        kwsBtn.textContent = 'Disable Keyword Spotter';
        logEv('KWS started');
      } else {
        try { await kwsEngine?.stop(); } catch(_){}
        kwsOn = false;
        kwsStatus.textContent = 'KWS: Off';
        kwsStatus.classList.remove('on');
        kwsBtn.textContent = 'Enable Keyword Spotter';
        logEv('KWS stopped');
      }
    });

  </script>

  <!--
    OPTIONAL: if you plan to use Porcupine Web, add its script here.
    <script src="https://cdn.picovoice.ai/porcupine/porcupine-web-en-worker.js"></script>
    <script src="https://cdn.picovoice.ai/porcupine/porcupine-web.js"></script>
    Then fill ACCESS_KEY and KEYWORDS URLs above.
  -->
</body>
</html>
